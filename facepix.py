# -*- coding: utf-8 -*-
"""FacePix.ipynb

Automatically generated by Colab.


"""

#FacePix dataset

# -*- coding: utf-8 -*-

# Author: Bouchene Mohammed Mehdi
#  FacePix dataset


# Import necessary modules
import os
import sys
import shutil
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
from imutils import paths
import random
import matplotlib.pyplot as plt
import cv2
import numpy as np
from skimage.feature import hog
import re
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.linear_model import RidgeClassifier
import time


# Constants
CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'facepix:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F82200%2F216251%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240416%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240416T220604Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D54f8e63f75eb9f007319bb00dfa5806c67cf952dcef33d78cce6ff2910939bdf66632e852fe360f3d3ec81e194e5605b19ceb1724c05f250a52f7be2e622a189a1ae3931ee4be20d5e6197d202c415415aedc509cc668beb8dde4d4a561cbfd84b52d95bafc2d3e6c4b0a24e068eeff999954e3c65a2b80a363f0b03c5f9b06f3745fe74344384886b8cc8e786259822365afe2ef66cbc54fc3bf52d42045538c88ff1d803e35a1fcc115a66f158d08a155cdc67e7409f3a49d9e5220022b5e17159d0d9ec3de0a8be8ee317a29eb0ff3953d055a9a62d3d846976ea1cb621303a293f7aaae5c2762906d258c4c689a54aabd2f9cd99d7a155880d8cbfbf1d5f'
KAGGLE_INPUT_PATH = '/kaggle/input'
KAGGLE_WORKING_PATH = '/kaggle/working'
KAGGLE_SYMLINK = 'kaggle'

# Function to extract ID from filename
def extract_id_from_filename(filename):
    """
    Extract the individual's ID from the filename.

    Args:
        filename (str): The filename of the face image.

    Returns:
        int: The individual's ID.
    """
    match = re.search(r'/(\d+)\(\-?\d+\)\.jpg', filename)
    if match:
        return int(match.group(1))
    else:
        return None

# Function to extract features and labels from face images
def extract_features_and_labels(face_image_files):
    """
    Extract features and labels from the face images.

    Args:
        face_image_files (list): The list of face image files.

    Returns:
        hog_features (np.array): The extracted HOG features.
        ids (np.array): The extracted IDs.
    """
    hog_features = []
    ids = []

    for file in face_image_files:
        face_image = convert_to_gray(file)
        face_image = resize_image(face_image, 362)
        features = hog(face_image, orientations=25, pixels_per_cell=(36, 36), cells_per_block=(2, 2), transform_sqrt=False)
        id = extract_id_from_filename(file)
        ids.append(id)
        hog_features.append(features)

    return np.array(hog_features), np.array(ids)

# Function to convert an image to grayscale
def convert_to_gray(face_image_path):
    """
    Read an image from the given path and convert it to grayscale.

    Args:
        face_image_path (str): The path of the face image file.

    Returns:
        face_gray_image: The grayscale face image.
    """
    face_image = cv2.imread(face_image_path)
    face_gray_image = cv2.cvtColor(face_image, cv2.COLOR_BGR2GRAY)
    return face_gray_image

# Function to resize an image
def resize_image(face_image, size):
    """
    Resize an image to the given size.

    Args:
        face_image: The input face image.
        size (int): The desired size.

    Returns:
        resized_face_image: The resized face image.
    """
    resized_face_image = cv2.resize(face_image, (size, size), interpolation=cv2.INTER_AREA)
    return resized_face_image

# Function to display random images
def display_random_images(imgorl, num_images=5):
    """
    Display a specified number of randomly chosen images from a given list of image paths.

    Parameters:
    imgorl (list): A list of image paths.
    num_images (int): The number of images to display. Default is 5.

    Returns:
    None
    """
    random_images = random.sample(imgorl, num_images)

    fig = plt.figure(figsize=(12, 12))

    for i, img_path in enumerate(random_images):
        img = cv2.imread(img_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        ax = fig.add_subplot(1, num_images, i+1)
        ax.imshow(img)
        plt.axis('off')

    plt.show()

# Function to train and evaluate the model
def train_and_evaluate_model(hog_features, face_labels, test_size=0.3, random_state=0):
    """
    Train and evaluate the model.

    Args:
        hog_features (np.array): The HOG features for training.
        face_labels (np.array): The face labels for training.
        test_size (float): The size of the test set.
        random_state (int): The seed for the random number generator.

    Returns:
        None
    """
    trainX, testX, trainY, testY = train_test_split(hog_features, face_labels, stratify=face_labels, random_state=random_state)

    print("[INFO] The number of images used in training: " + str(trainX.shape[0]))
    print("[INFO] The number of images used in testing: " + str(testX.shape[0]))

    start_time = time.time()

    classifier = RidgeClassifier()
    model = classifier.fit(trainX, trainY)

    print("--- %s seconds ---" % (time.time() - start_time))

    print("[INFO] Evaluating...")
    predictions = model.predict(testX)
    report = classification_report(testY, predictions, digits=4)

    print(report)

    accp = accuracy_score(testY, predictions)
    numbrcorr = accuracy_score(testY, predictions, normalize=False)

    tr_preds = model.predict(trainX)
    trcc = accuracy_score(trainY, tr_preds)

    print("Train Accuracy: %.4f%%" % (trcc * 100.0))
    print("Test Accuracy: %.4f%%" % (accp *100.0))
    print("Number of correctly classified faces: " + str(numbrcorr))

# Unmount and clear the input directory
!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

# Create symbolic links for input and working directories
try:
    os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
    pass
try:
    os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
    pass

# Download and extract data
for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
                with ZipFile(tfile) as zfile:
                    zfile.extractall(destination_path)
            else:
                with tarfile.open(tfile.name) as tarfile:
                    tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

# Get list of face image files
fx = list(paths.list_images('/kaggle/input/facepix/FacePix/'))

# Display random face images
display_random_images(fx)

# Extract features and labels from face images
hog_features, ids = extract_features_and_labels(fx)

# Train and evaluate the model
train_and_evaluate_model(hog_features, ids, random_state=0)